/*
	*** OpenGL Viewer Widget (subclassing QGLWidget)
	*** src/gui/viewer.uih
	Copyright T. Youngs 2013

	This file is part of uChroma.

	uChroma is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	uChroma is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with uChroma.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef FQPLOT_VIEWER_H
#define FQPLOT_VIEWER_H

#include <QtOpenGL/QGLWidget>
#include <QtCore/QObject>
#include <FTGL/ftgl.h>
#include "gui/viewer_primitive.h"
#include "gui/viewer_primitiveinfo.h"
#include "gui/viewer_primitivelist.h"
#include "gui/viewer_textprimitive.h"
#include "base/colourscale.h"
#include "base/data2d.h"
#include "templates/list.h"
#include "templates/reflist.h"

// Forward Declarations
class ColourScale;
class UChromaWindow;
class Collection;
class DisplayDataSet;

// Base rendering widget
class Viewer : public QGLWidget
{
	Q_OBJECT

	public:
	// Constructor / Destructor
	Viewer(QWidget *parent);
	~Viewer();


	/*
	 * OpenGL Function Declarations
	 */
	public:
	static PFNGLBEGINQUERYPROC glBeginQuery;
	static PFNGLENDQUERYPROC glEndQuery;
	static PFNGLGENQUERIESPROC glGenQueries;
	static PFNGLGETQUERYOBJECTIVPROC glGetQueryObjectiv;
	static PFNGLGETQUERYOBJECTUI64VPROC glGetQueryObjectui64v;


	/*
	 * Link to UChroma
	 */
	private:
	// UChromaWindow pointer
	UChromaWindow* uChroma_;
	
	public:
	// Set UChromaWindow pointer
	void setUChroma(UChromaWindow* ptr);


	/*
	// Character / Setup
	// (in viewer_funcs.cpp)
	*/
	private:
	// Flags indicating presence of various GL_EXTENSIONS
	bool vboExtension_, timerExtension_;
	// Width, height, and aspect ratio of the canvas
	GLsizei contextWidth_, contextHeight_;
	// Flag to indicate whether we may draw to the canvas
	bool valid_;
	// Flag indicating if we are currently drawing to this canvas
	bool drawing_;
	// Flag specifying whether we are currently rendering offscreen
	bool renderingOffscreen_; 
	// Projection matrix for the scene
	Matrix projectionMatrix_;
	// Field of view angle used in projectionMatrix_ when using perspective
	double perspectiveFieldOfView_;
	// View matrix for the scene (modified by mouse/keyboard input)
	Matrix viewMatrix_;
	// Inverse of view matrix
	Matrix viewMatrixInverse_;
	// Viewport matrix for the scene
	GLuint viewportMatrix_[4];
	// Font file last passed to setupFont()
	QString fontFile_;
	// FTGL font for text
	FTFont* font_;
	// Basic font height (from baseline to top of normal height letter)
	double fontBaseHeight_;
	// String containing time taken to do last render
	QString renderTime_;

	protected:
	// Initialise context widget (when created by Qt)
	void initializeGL();
	// General repaint callback
	void paintGL();
	// Resize function
	void resizeGL(int, int);

	public:
	// Setup font specified
	bool setupFont(QString fontName);
	// Return the current height of the drawing area
	GLsizei contextHeight() const;
	// Return the current width of the drawing area
	GLsizei contextWidth() const;
	// Probe widget/context/format features
	void probeFeatures();
	// Check for GL error
	void checkGlError();
	// Refresh widget / scene
	void postRedisplay();
	// Return calculated projection matrix
	Matrix calculateProjectionMatrix(bool perspective, double fov, double viewZOffset);
	// Update transformation (view) matrix
	void setViewMatrix(Matrix& mat);
	// Return transformation (view) matrix
	Matrix viewMatrix();
	// Render or grab image
	QPixmap generateImage(int w, int h);
	// Reset current view
	void resetView();
	// Project given model coordinates into world coordinates
	Vec3<double> modelToWorld(Vec3<double> &modelr);
	// Project given model coordinates into screen coordinates
	Vec4<double> modelToScreen(Vec3<double> &modelr, double screenradius = -1.0);
	// Return zoom level, assuming orthogonally-aligned view matrix, to display coordinates supplied
	double calculateRequiredZoom(double xExtent, double yExtent, double fraction);
	// Convert screen coordinates into model space coordinates
	Vec3<double> screenToModel(int x, int y, double z);


	/*
	// Mouse / Keyboard Input
	// (in viewer_input.cpp)
	*/
	private:
	// Canvas coordinates of mouse down
	Vec3<double> rMouseDown_;
	// Canvas coordinates of mouse cursor
	Vec3<double> rMouseLast_;
	// Current state of mouse buttons
	Qt::MouseButtons buttonState_;

	protected:
	// Qt Virtual (mouse press event)
	void mousePressEvent(QMouseEvent*);
	// Qt Virtual (mouse release event)
	void mouseReleaseEvent(QMouseEvent*);
	// Qt Virtual (mouse move event)
	void mouseMoveEvent(QMouseEvent*);
	// Qt Virtual (mouse wheel event)
	void wheelEvent(QWheelEvent*);

	public:
	// Return mouse coordinates at last mousedown event
	Vec3<double> rMouseDown();
	// Return mouse coordinates at last mousemove event
	Vec3<double> rMouseLast();

	public slots:
	// Qt Slot (key press event)
	void keyPressEvent(QKeyEvent*);
	// Qt Slot (key release event)
	void keyReleaseEvent(QKeyEvent*);


	/*
	// Object Lists
	*/
	private:
	// List of filtered solid primitives
	List<PrimitiveInfo> solidPrimitives_;
	// List of filtered transparent primitives
	List<PrimitiveInfo> transparentPrimitives_;
	// List of line primitives
	List<PrimitiveInfo> linePrimitives_;
	// List of general text primitives
	TextPrimitiveList textPrimitives_;


	/*
	// Rendering Preferences
	// (in viewer_prefs.cpp)
	*/ 
	private:
	// Flag specifying whether framebuffer should be used for offscreen rendering
	bool useFrameBuffer_;
	// Flag specifying whether to correct transparency artefacts
	bool correctTransparency_;
	// Flag specifying whether the view has perspective
	bool hasPerspective_;
	// Line width to use for line primitives
	double lineWidth_;
	
	public:
	// Set whether framebuffer should be used for offscreen rendering
	void setUseFrameBuffer(bool b);
	// Return whether framebuffer should be used for offscreen rendering
	bool useFrameBuffer();
	// Set whether to correct transparency artefacts
	void setCorrectTransparency(bool b);
	// Return whether to correct transparency artefacts
	bool correctTransparency();
	// Return whether the view has perspective
	bool hasPerspective();
	// Set whether this view has perspective
	void setHasPerspective(bool b);
	// Set line width to use for line primitives
	void setLineWidth(double lineWidth);

	/*
	// User Functions / Data
	// (in viewer_user.cpp)
	*/
	private:
	// Reference list of all created primitives (to which all user primitives must be added)
	RefList<Primitive,int> primitiveList_;
	// Display primitives
	Primitive axisPrimitives_[3], interactionPrimitive_, interactionBoxPrimitive_, boundingBoxPrimitive_;
	// Axis text primitives
	TextPrimitiveList axisTextPrimitives_[3];
	// Y axis clip plane definitions
	GLdouble clipPlaneBottom_[4], clipPlaneTop_[4], clipPlaneYMin_, clipPlaneYMax_;
	// Delta to add to Y clip plane limits
	double clipPlaneDelta_;
	// Current axis position of slice primitive
	double slicePrimitivePosition_;

	private:
	// Create necessary primitives (called once when Viewer is constructed)
	void createPrimitives();
	// Setup basic GL properties
	void setupGL();
	// Construct line surface representation of data
	void constructLineSurface(PrimitiveList& primitives, const Array<double>& abscissa, List<DisplayDataSet>& displayData, ColourScale colourScale);
	// Construct line surface representation of data
	void constructGridSurface(PrimitiveList& primitives, const Array<double>& abscissa, List<DisplayDataSet>& displayData, ColourScale colourScale);
	// Construct gridded surface representation of data
	Vec3<double> constructVertexNormals(const Array<double>& abscissa, int index, DisplayDataSet* targetDataSet, DisplayDataSet* previousDataSet, DisplayDataSet* nextDataSet, int nPoints);
	// Construct normal / colour surface data for dataset specified
	void constructSurfaceStrip(const Array<double>& abscissa, DisplayDataSet* targetDataSet, double yAxisScale, Array< Vec3< double > >& normals, Array< Vec4< GLfloat > >& colours, const ColourScale& colourScale, DisplayDataSet* previousDataSet, DisplayDataSet* nextDataSet);
	// Construct full surface representation of data
	void constructFullSurface(PrimitiveList& primitives, const Array<double>& abscissa, List<DisplayDataSet>& displayData, ColourScale colourScale);
	// Create/update surface primitive for specified collection
	bool updateSurfacePrimitive(Collection* collection, bool forceUpdate = false);

	public:
	// Add supplied collection primitive to list
	void addCollectionPrimitive(Primitive* primitive);
	// Remove collection primitive from primitive list
	void removeCollectionPrimitive(Primitive* primitive);
	// Clear specified axis primitives
	void clearAxisPrimitives(int axis);
	// Add line to axis primitive
	void addAxisLine(int axis, Vec3<double> v1, Vec3<double> v2);
	// Add entry to axis text primitive
	void addAxisText(int axis, QString text, Vec3<double> origin, Matrix transform, TextPrimitive::HorizontalAnchor textAlignment = TextPrimitive::AnchorCentre);
	// Calculate axis slice value at current mouse position
	void calculateMouseAxisValue();
	// Set interaction primitive to specified axis
	void setInteractionPrimitive(int axis);
	// Create bounding box
	void createBoundingBox(int type, double planeY);
	// Set Y clip plane limits
	void setYClip(double yMin, double yMax);
	
	signals:
	// View was clicked on
	void viewClicked();
	// Return string containing time taken to do last render
	QString renderComplete(QString timeTaken);
	// Data for one or more surface primitives was updated
	void surfacePrimitivesUpdated();


	/*
	 * Image Formats
	 */
	public:
	// Available image export formats
        enum ImageFormat { BMPFormat, PGFormat, PNGFormat, PPMFormat, XBMFormat, X11Format, nImageFormats };
        static ImageFormat imageFormat(const char* name);
        static ImageFormat imageFormatFromFilter(const char* s);
        static const char *imageFormatFilter(ImageFormat bf);
        static const char *imageFormatExtension(ImageFormat bf);
};

#endif
